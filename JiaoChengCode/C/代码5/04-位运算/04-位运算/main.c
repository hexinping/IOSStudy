//
//  main.c
//  04-位运算
//
//  Created by apple on 14-2-23.
//  Copyright (c) 2014年 itcast. All rights reserved.
//

#include <stdio.h>
/*
 &    &&
 |    ||
 ^
 ~
 >>
 <<
 */
int main(int argc, const char * argv[])
{
    /*
     1.按位与 &
     特点：只有对应的“两位都是1”才返回1，否则返回0
     规律：任何数按位与上1结果还是那个数
     口诀：一假则假
     
     
      1001
    & 0101
    ————————
      0001
     
     
     
       1001
     & 1111
     ————————
       1001
     
     int result = 9 & 5;
     printf("result = %d\n", result);
     */
    
    
    /*
     2.按位或 |
     特点：只要有一个是1结果就是1
     口诀：一真则真
     
       1001
     | 0101
     ————————
       1101
     
     int result = 9 | 5;
     printf("result = %d\n", result);

     */
    
    
    /*
     3.按位异或 ^
     特点：对应的两位不同返回1 ，相同返回0
     
     
       1001
     ^ 0101
     ______
       1100
     
     
       1001
     ^ 0101
     _______
       1100
     
       1100
     ^ 0011
     _______
       1111
     
      0011
    ^ 1001
     _____
      1010
     
       1010
     ^ 0101
     _______
       1111
     
     
      1001
    ^ 1001
     _______
      0000
     
     
       1001
     ^ 0000
     _______
       1001
     
     
     1001
     1001
     ____
     0000
     
     
     0000
     0101
     _____
     0101
     */
    
//    int result = 9 ^ 5;
//    int result = 9 ^ 5 ^ 3;
//    int result = 3 ^ 9 ^ 5;
//    结论1.多个整数按位异或结果和顺序没有关系
    
//    int result = 9 ^ 9;
//    结论2.相同整数按位异或结果为0
    
//    int result = 9 ^ 0 ;
//    结论3.任何整数按位异或上0结果还是那个整数
    
//    int result = 9 ^ 5 ^ 9;
//    printf("result = %d\n", result);
    
    /*
     4. 取反 ～
     特点：0变1 1变0
     
       0000 0000 0000 0000 0000 0000 0000 1001   //9
     ~ 1111 1111 1111 1111 1111 1111 1111 0110  //-10 补码
     
     - 0000 0000 0000 0000 0000 0000 0000 0001
       1111 1111 1111 1111 1111 1111 1111 0101  //-10 反码
       1000 0000 0000 0000 0000 0000 0000 1010 //-10  原码
     
     
     
     
      1000 0000 0000 0000 0000 0000 0000 1010 //-10 原码
      1111 1111 1111 1111 1111 1111 1111 0101 //-10 反码
     +0000 0000 0000 0000 0000 0000 0000 0001
      1111 1111 1111 1111 1111 1111 1111 0110 //-10补码
     */
    
//    规律：一个数的负数 取反+1
//    int result = ~9 + 1;
//    printf("result = %d\n", result);
    
    
    /*
     5. 左移 <<
     格式： a << n  把整数a的二进制往左边移动n位
     
       9 << 1 == 18 9 * 2（1）
       9 << 2 == 36 9 * 2（2）
       9 << 3 == 72 9 * 2（3）
     0000 0000 0000 0000 0000 0000 0000 0000
     000 0000 0000 0000 0000 0000 0000 10010
     
     结论：往左边移动多少位就是乘以2的多少次方
     注意点：左移有可能改变数值的正负性
     使用场合：当要计算某个数乘以2的多少次方的时候用左移效率最高
     
     1001
     0010
    ——————
     0000 
    1001
   0000 
 0000
——————————
 00010010
     
     int result = 9 << 3;
     printf("result = %d\n", result);
     */
    
    
    /*
     6.右移 >>
     
     9 >> 1 == 4; 9/2(1)
     9 >> 2 == 2; 9/2(2)
     0000 0000 0000 0000 0000 0000 0000 0000
     000000 0000 0000 0000 0000 0000 0000 10
     
     结论：往右移多少位就是除以2的多少次方
     使用场合：当要计算某个数除以2的多少次方的时候用右移效率最高
     */
    int result = 9 >> 2;
    printf("result = %d\n", result);

    return 0;
}

